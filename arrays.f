C FILL AN INTEGER ARRAY OF THE STATED SIZE WITH THE GIVEN VALUE
      SUBROUTINE AIFILL(ARRAY, SIZE, VAL)
      INTEGER ARRAY(*), SIZE, VAL
      DO 10 I=1,SIZE
      ARRAY(I) = VAL
10    CONTINUE
      END

C INITIALIZE AN INTEGER ARRAY OF THE STATED SIZE WITH ZERO
      SUBROUTINE AIZERO(ARRAY, SIZE)
      INTEGER ARRAY(*), SIZE
      CALL AIFILL(ARRAY, SIZE, 0)
      END

C RETURN TRUE IF THE INTEGER ARRAY OF THE STATED SIZE CONTAINS THE
C GIVEN VALUE
      LOGICAL FUNCTION AICONT(ARRAY, SIZE, VAL)
      INTEGER ARRAY(*), SIZE, VAL, I
      AICONT = .FALSE.
      I=1
20    IF (I .GT. SIZE) GOTO 40
      IF (ARRAY(I) .EQ. VAL) GOTO 30
      I = I + 1
      GOTO 20
30    AICONT = .TRUE.
40    RETURN
      END

C RETURN TRUE IF THE SORTED INTEGER ARRAY OF THE STATED SIZE 
C CONTAINS THE GIVEN VALUE. NOTE THAT WE NEED TO BE CAREFUL
C WHEN THE MIDPOINT OF THE BINARY SEARCH ENDS UP EQUAL TO ONE
C OF THE ENDPOINTS. WE CHECK WHETHER THE DIFFERENCE IS LESS
C THAN OR EQUAL TO 1.
      LOGICAL FUNCTION AICONS(ARRAY, SIZE, VAL)
      INTEGER ARRAY(*), SIZE, VAL, I, FIRST, LAST, MID
      AICONS = .FALSE.
      FIRST = 1
      LAST = SIZE
50    IF (LAST - FIRST .LE.1) GOTO 80
      MID = (FIRST + LAST) / 2
      IF (ARRAY(MID) - VAL) 60, 90, 70
60    FIRST = MID
      GOTO 50
70    LAST = MID
      GOTO 50
80    IF ((ARRAY(FIRST) .NE. VAL) .AND. (ARRAY(LAST) .NE. VAL)) GOTO 100
90    AICONS = .TRUE.
100   RETURN
      END

C MOVE ALL DUPLICATE ENTRIES IN THE ARRAY UP TO THE HIGHEST INDEXES AND
C RETURN THE INDEX OF THE HIGHEST UNIQUE ENTRY. NOTE THAT THIS MODIFIES
C THE SUPPLIED ARRAY AND RETURNS A RESULT
      INTEGER FUNCTION AIDDUP(ARRAY, SIZE)
      INTEGER ARRAY(*), SIZE, I, J, K, VAL, M, N
C I STARTS AT 1 AND POINTS AT THE INDEX OF THE VALUE BEING TESTED FOR
C BEING A DUPLICATE. VAL IS THE VALUE AT INDEX I. J STARTS AT SIZE AND
C IS THE CURRENT SIZE OF THE UNIQUE PART OF THE ARRAY. EVERY TIME WE 
C HIT A DUPLICATE, IT GETS SWAPPED WITH THE VALUE AT J, AND J IS 
C DECREASED. K IS OUR CURRENT TEST INDEX
      I = 1
      J = SIZE
110   IF (J .EQ. I) GOTO 170
      VAL = ARRAY(I)
      K = I+1
120   M = ARRAY(K)
      IF (M .NE. VAL) GOTO 130
      N = ARRAY(J)
      ARRAY(J) = M
      ARRAY(K) = N
      J = J - 1
      GOTO 110   
130   K = K + 1
      IF (K .GT. J) GOTO 150
      GOTO 120
150   I = I+1
      GOTO 110
170   AIDDUP = J
      END
      

C IMPLEMENTATION OF QUICKSORT, SLIGHTLY HAMPERED BY NOT BEING ABLE TO
C CALL FUNCTIONS RECURSIVELY
      SUBROUTINE AIQSRT(ARRAY, SIZE)
      INTEGER ARRAY(*), SIZE, I, J, K, VAL, M, N
C WE TRACK THE REGIONS THAT NEED TO BE SORTED BY ADDING ENTRIES TO 
C AN ARRAY WITH THE FIRST AND LAST POSITIONS (BOTH INCLUSIVE)
C IDEALLY, THE BOUND WOULD BE SIZE * LN2(SIZE) BUT WE'RE BEING CAVALIER
      INTEGER TASKS(SIZE * SIZE, 2)
C TAP = TASKS ADD POINTER, THE INDEX OF THE NEXT FREE ROW
C TEP = TASKS EXECUTE POINTER, THE INDEX OF THE NEXT ROW TO BE EXECUTED
C IF TEP = TAP THEN WE HAVE RUN OUT OF TASKS
C FIRST AND LAST ARE FOR CURRENT TASK, PIVOT = THE PIVOT
      INTEGER TAP, TEP, FIRST, LAST, PIVOT, PINDEX
C IF WE GET THROUGH THE WHOLE ARRAY FINDING THINGS LESS THAN OR EQUAL
C TO THE PIVOT THEN EITHER EVERYTHING IN THE ARRAY IS THE SAME, OR WE
C ACCIDENTALLY PICKED THE HIGHEST NUMBER AS THE PIVOT. IN WHICH CASE
C WE WANT TO CHECK IF WE FOUND ANY OTHER NUMBERS.
      INTEGER FOUND(2)
C WHETHER OR NOT WE FOUND MORE THAN ONE VALUE IN OUR PASS THROUGH
      LOGICAL ISUNIQ
C OUR FIRST TASK IS TO SORT THE ENTIRE ARRAY
      TASKS(1, 1) = 1
      TASKS(1, 2) = SIZE
      TAP = 2
      TEP = 0
200   TEP = TEP + 1
      IF (TEP .EQ. TAP) GOTO 299
      PRINT *, ""
      FIRST = TASKS(TEP, 1)
      LAST = TASKS(TEP, 2)
      PRINT *, "TEP=", TEP, FIRST, LAST
      CALL AIDUMP(ARRAY, SIZE)
C IS THE CURRENT TASK AN ARRAY OF SIZE 1? IF YES THERE'S NOTHING TO DO
C OR, INT THE EVENT THAT OUR FIRST ENTRY IS A HIGHER INDEX THAN THE 
C LAST (COULD HAPPEN FOR SOME PIVOT VALUES) THEN THERE'S ALSO NOTHING
C TO DO
      IF (FIRST .GE. LAST) GOTO 200
      IF (LAST - FIRST .GT. 1) GOTO 210
C TASK HAS SIZE 2
      IF (ARRAY(FIRST) .LT. ARRAY(LAST)) GOTO 200
      N = ARRAY(FIRST)
      ARRAY(FIRST) = ARRAY(LAST)
      ARRAY(LAST) = N
      GOTO 200
210   PINDEX = (LAST + 1 - FIRST) / 2
      PIVOT = ARRAY(PINDEX)
      PRINT *, "PINDEX", PINDEX, "PIVOT", PIVOT
C PARTITION THE ARRAY SO THINGS LESS THAN THE PIVOT COME FIRST, THEN
C THE PIVOT, THEN THINGS GREATER THAN THE PIVOT
215   I = FIRST
      J = LAST
      FOUND(1) = ARRAY(I)
      ISUNIQ = .TRUE.
220   IF (I .EQ. J) GOTO 270
      IF (ARRAY(I) .EQ. FOUND(1)) GOTO 230
C FOUND AT LEAST ONE OTHER VALUE
      FOUND(2) = ARRAY(I)
      ISUNIQ = .FALSE.
230   IF (ARRAY(I) .LT. PIVOT) GOTO 250
      IF (ARRAY(J) .GE. PIVOT) GOTO 260
C I IS NOW POINTING AT A VALUE GREATER OR EQUAL TO THE PIVOT, AND J IS 
C POINTING AT A VALUE LESS THAN THE PIVOT, SO SWAP THEM
      PRINT *, "SWAP", I, J
      M = ARRAY(I)
      ARRAY(I) = ARRAY(J)
      ARRAY(J) = M
      GOTO 220
250   I = I + 1
C      PRINT *, "I", I
      GOTO 220
260   J = J - 1
C      PRINT *, "J", J
      GOTO 220
C IF I = LAST, WE NEED TO SEE WHETHER EVERYTHING IN THE ARRAY WAS THE
C SAME (IN WHICH CASE IT IS SORTED), IF NOT THEN WE MANAGED TO PICK
C THE HIGHEST VALUE IN THE ARRAY AS THE PIVOT AND WE NEED TO TRY AGAIN
C WITH A DIFFERENT VALUE
270   IF (I .NE. LAST) GOTO 280
      IF (ISUNIQ) GOTO 200
      PIVOT = MIN0(FOUND(1), FOUND(2))
      GOTO 215
280   TASKS(TAP, 1) = FIRST
      TASKS(TAP, 2) = I
      TAP = TAP + 1
      TASKS(TAP, 1) = I+1
      TASKS(TAP, 2) = LAST
      TAP = TAP + 1
      GOTO 200            
299   END

      SUBROUTINE AIDUMP(ARRAY, SIZE)
      INTEGER ARRAY(*), SIZE
      DO 300 I=1,SIZE
      PRINT *,I, ARRAY(I)
300   CONTINUE
      END
